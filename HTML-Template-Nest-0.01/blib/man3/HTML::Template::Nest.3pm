.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Template::Nest 3pm"
.TH HTML::Template::Nest 3pm "2016-11-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Template::Nest \- manipulate a nested html template structure via a perl hash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&        page.html:
\&        <html>
\&                <head>
\&                        <style>
\&                                div { 
\&                                        padding: 20px;
\&                                        margin: 20px;
\&                                        background\-color: yellow;
\&                                }
\&                        </style>
\&                </head>
\&
\&                <body>
\&                        <!\-\- TMPL_VAR NAME=contents \-\->
\&                </body>
\&        </html>
\&         
\&
\&
\&        box.html:
\&        <div>
\&                <!\-\- TMPL_VAR NAME=title \-\->
\&        </div>
\&
\&
\&        use HTML::Template::Nest;
\&
\&        my $page = {
\&                NAME => \*(Aqpage\*(Aq,
\&                contents => [{
\&                        NAME => \*(Aqbox\*(Aq,
\&                        title => \*(AqFirst nested box\*(Aq
\&                }]
\&        };
\&
\&        push @{$page\->{contents}},{
\&                NAME => \*(Aqbox\*(Aq,
\&                title => \*(AqSecond nested box\*(Aq
\&        };
\&
\&        my $nest = HTML::Template::Nest\->new(
\&                template_dir => \*(Aq/html/templates/dir\*(Aq
\&        );
\&
\&        print $nest\->to_html( $page );
\&  
\&        
\&        # output:
\&
\&    <html>
\&            <head>
\&                    <style>
\&                            div { 
\&                                    padding: 20px;
\&                                    margin: 20px;
\&                                    background\-color: yellow;
\&                            }
\&                    </style>
\&            </head>
\&
\&            <body>          
\&            <div>
\&                    First nested box
\&            </div>
\&            <div>
\&                    Second nested box
\&            </div>
\&            </body>
\&    </html>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::Template is great because it is simple, and doesn't violate \s-1MVC\s0 in the uncomfortable way Mason does. However if you want components you can manipulate easily and nest arbitrarily, then the raw interface can be labour intensive to work with. For example, to recreate the example in the synopsis using plain HTML::Template, you would need to do something like:
.PP
# first create and populate the inner templates
my \f(CW$box1\fR = HTML::Template\->new( filename => 'box.html' ); 
\&\f(CW$box1\fR\->param( title => 'First nested box' );
my \f(CW$box2\fR = HTML::Template\->new( filename => 'box.html' );
\&\f(CW$box2\fR\->param( title => 'Second nested box' );
.PP
# feed the output to the contents of the parent
my \f(CW$page\fR = HTML::Template\->new( filename => 'page.html' );
\&\f(CW$page\fR\->param( contents => \f(CW$box1\fR\->output.$box2\->output );
.PP
print \f(CW$page\fR\->output;
.PP
It's easy to see how this quickly becomes inconvenient as the size of the component structure increases. It would be better if a routine could create and fill in the params recursively \- and this is where HTML::Template::Nest comes in.
.PP
Nest uses HTML::Template to create whatever nested structure of templates you give it. Nest
.PP
\&\- accepts the input structure as a hashref
\&\- with each (sub)component as a hashref, 
\&\- and each list of components as an arrayref
.PP
ie. the components are represented in terms of the most obvious basic perl datatypes, which means you are free to form your structure in any of the many ways you can manipulate normal hashes/arrays. This ends up being a surprisingly powerful templating system with some great advantages \- the most obvious being true separation of controller from view. E.g. lets say you wanted to create a 2 row 2 column table using the following templates:
.PP
table.html:
<table>
    <!\-\- \s-1TMPL_VAR\s0 NAME=rows \-\->
</table>
.PP
row.html:
<tr>
    <!\-\- \s-1TMPL_VAR\s0 NAME=columns \-\->
</tr>
.PP
column.html 
<td>
    <!\-\- \s-1TMPL_VAR\s0 NAME=value \-\->
</td>
.PP
If you were feeling masochistic, you could do this:
.PP
my \f(CW$table\fR = {
    \s-1NAME\s0 => 'table',
    rows => [{
        \s-1NAME\s0 => 'table_row',
        columns => [{
            \s-1NAME\s0 => 'table_column',
            value => 'Row 1 Col 1'
        },{
            \s-1NAME\s0 => 'table_column',
            value => 'Row 1 Col 2'
        }]
    },{
        \s-1NAME\s0 => 'table_row',
        columns => [{
            \s-1NAME\s0 => 'table_column',
            value => 'Row 2 Col 1'
        },{
            \s-1NAME\s0 => 'table_column',
            value => 'Row 2 Col 2'
        }]
    }]
};
.PP
print \f(CW$nest\fR\->to_html( \f(CW$table\fR );
.PP
Note how each hashref gets a '\s-1NAME\s0' \- this indicates the filename of the template (concat template_ext to get the filename). So '\s-1NAME\s0' is a special indicator. The rest of the variables in the hash are interpreted as fill-in parameters. If the fill in params point to text, then these are filled in directly. However if a fill in param is a hashref, then this is understood as a subcomponent, and turned into html before filling in. If a fill in param points to an arrayref, each element in the list is interpreted first (as a component, sublist or plain text) before the generated html is strung end to end in list order.
.PP
You can mix and match text fill-ins vs. sub component fill-ins to your hearts content. For example:
.PP
article.html:
<div class='article'>
    <div class='columns'>
        <!\-\- \s-1TMPL_VAR\s0 NAME=columns \-\->
    </div>
</div>
.PP
article_column.html:
<div class='article\-column'>
    <!\-\- \s-1TMPL_VAR\s0 NAME=contents \-\->
</div>
.PP
my \f(CW$article\fR = {
    \s-1NAME\s0 => 'article',
    columns => [
        'Blah blah bla my column 1 is just a lump of text',
        { 
            \s-1NAME\s0 => 'article_column',
            contents => 'but col 2 is a subcomponent'
.PP
.Vb 3
\&        }
\&    ]
\&};
.Ve
.PP
(Obviously it's your job to make sure you create a structure that generates desirable html!)
.PP
Of course, you don't have to specify your structure with a single declaration \- and why would you with the full flexibility of perl behind you? For example it makes sense to create a repeating structure like a table using a loop:
.PP
my \f(CW$rows\fR = [];
for my \f(CW$i\fR (1..2){
.PP
.Vb 1
\&    my $cols = [];
\&
\&    for my $j (1..2){
\&         push @$cols,{ 
\&            NAME => \*(Aqcolumn\*(Aq,
\&            value => \*(AqRow $i Col $j\*(Aq
\&        };
\&    }
\&    
\&    push @$rows,{
\&        NAME => \*(Aqrow\*(Aq,
\&        columns => $cols
\&    };
.Ve
.PP
}
.PP
my \f(CW$table\fR = { 
    \s-1NAME\s0 => 'table',
    rows => \f(CW$rows\fR
};
.PP
print \f(CW$nest\fR\->to_html( \f(CW$table\fR );
.PP
This is a good moment to explain that HTML::Template::Nest *only* uses the \s-1TMPL_VAR\s0 declaration from HTML::Template. ie if you want to use \s-1TMPL_LOOP, TMPL_INCLUDE, TMPL_IF\s0 etc. then HTML::Template::Nest is not for you. Why does HTML::Template::Nest not use these? Because the aim is to create a templating system with all of the processing in the perl, and no processing (other than filling in the template variables) in the template. After all if you are looping in the template, then your view and controller are not separate. (And with HTML::Template::Nest it's so very easy to create repetitive structures, so why would you want this anyway?)
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
constructor for an HTML::Template::Nest object.
.PP
my \f(CW$nest\fR = HTML::Template::Nest\->new( \f(CW%opts\fR );
.PP
\&\f(CW%opts\fR can contain any of the methods HTML::Template::Nest accepts. For example you can do:
.PP
my \f(CW$nest\fR = HTML::Template::Nest\->new( template_dir => '/my/template/dir' );
.PP
or equally:
.PP
my \f(CW$nest\fR = HTML::Template::Nest\->\fInew()\fR;
\&\f(CW$nest\fR\->template_dir( '/my/template/dir' );
.PP
(And you should set template_dir one way or another as a minimum!)
.SS "name_label"
.IX Subsection "name_label"
The default is \s-1NAME \s0(all-caps, case-sensitive). Of course if \s-1NAME\s0 is interpreted as the filename of the template, then you can't use \s-1NAME\s0 as one of the variables in your template. ie
.PP
<!\-\- \s-1TMPL_VAR\s0 NAME=NAME \-\->
.PP
will never get populated. If you really are adamant about needing to have a template variable called '\s-1NAME\s0' \- or you have some other reason for wanting an alternative label point to your template filename, then you can set name_label:
.PP
\&\f(CW$nest\fR\->name_label( '\s-1GOOSE\s0' );
.PP
and now
.PP
my \f(CW$component\fR = {
    \s-1GOOSE\s0 => 'name_of_my_component'
    ...
};
.SS "show_labels"
.IX Subsection "show_labels"
Get/set the show_labels property. This is a boolean with default 0. Setting this to 1 results in adding comments to the output html so you can identify which template output text came from. This is useful in development when you have many templates. E.g. adding
.PP
\&\f(CW$nest\fR\->\fIshow_labels\fR\|(1);
.PP
to the example in the synopsis results in the following:
.PP
<!\-\- \s-1BEGIN\s0 page \-\->
<html>
	<head>
		<style>
			div { 
				padding: 20px;
				margin: 20px;
				background-color: yellow;
			}
		</style>
	</head>
.PP
.Vb 1
\&        <body>
.Ve
.PP
<!\-\- \s-1BEGIN\s0 box \-\->
<div>
	First nested box
</div>
<!\-\- \s-1END\s0 box \-\->
.PP
<!\-\- \s-1BEGIN\s0 box \-\->
<div>
	Second nested box
</div>
<!\-\- \s-1END\s0 box \-\->
.PP
.Vb 3
\&        </body>
\&</html>
\&<!\-\- END page \-\->
.Ve
.PP
What if you're not templating html, and you still want labels? Then you should set comment_tokens to whatever is appropriate for the thing you are templating.
.SS "comment_tokens"
.IX Subsection "comment_tokens"
Use this in conjunction with show_labels. Get/set the tokens used to define comment labels. Expects a 2 element arrayref. E.g. if you were templating javascript you could do:
.PP
\&\f(CW$nest\fR\->comment_tokens([ '/*','*/' ]);
Now your output will have labels like
.PP
/* \s-1BEGIN\s0 my_js_file */
\&...
/* \s-1END\s0 my_js_file */
.PP
You can set the second comment token as an empty string if the language you are templating does not use one. E.g. for Perl:
\&\f(CW$nest\fR\->comment_tokens([ '#','' ]);
.SS "template_dir"
.IX Subsection "template_dir"
Get/set the dir where HTML::Template::Nest looks for your templates. E.g.
.PP
\&\f(CW$nest\fR\->template_dir( '/my/template/dir' );
.PP
Now if I have
.PP
my \f(CW$component\fR = {
    \s-1NAME\s0 => 'hello',
    ...
}
.PP
and template_ext = '.html', we'll expect to find the template at
.PP
/my/template/dir/hello.html
.PP
Note that if you have some kind of directory structure for your templates (ie they are not all in the same directory), you can do something like this:
.PP
my \f(CW$component\fR = {
    \s-1NAME\s0 => '/my/component/location',
    contents => 'some contents or other'
};
.PP
HTML::Template::Nest will then prepend \s-1NAME\s0 with template_dir, append template_ext and look in that location for the file. So in our example if template_dir = '/my/template/dir' and template_ext = '.html' then the template file will be expected to exist at
.PP
/my/template/dir/my/component/location.html
.PP
Of course if you want components to be nested arbitrarily, it might not make sense to contain them in a prescriptive directory structure.
.SS "template_ext"
.IX Subsection "template_ext"
Get/set the template extension. This is so you can save typing your template extension all the time if it's always the same. The default is '.html' \- however, there is no reason why this templating system could not be used to construct any other type of file (or why you could not use another extension even if you were producing html). So e.g. if you are wanting to manipulate javascript files:
.PP
\&\f(CW$nest\fR\->template_ext('.js');
.PP
then
.PP
my \f(CW$js_file\fR = {
    \s-1NAME\s0 => 'some_js_file'
    ...
}
.PP
So here HTML::Template::Nest will look in template_dir for
.PP
some_js_file.js
.PP
If you don't want to specify a particular template_ext (presumably because files don't all have the same extension) \- then you can do
.PP
\&\f(CW$nest\fR\->template_ext('');
.PP
In this case you would need to have \s-1NAME\s0 point to the full filename. ie
.PP
\&\f(CW$nest\fR\->template_ext('');
.PP
my \f(CW$component\fR = {
    \s-1NAME\s0 => 'hello.html',
    ...
}
.SS "to_html"
.IX Subsection "to_html"
Convert a template structure to html. Expects a hashref containing hashrefs/arrayrefs/plain text. Outputs plain html.
.PP
e.g.
.PP
widget.html:
<div class='widget'>
    <h4>I am a widget</h4>
    <div>
        <!\-\- \s-1TMPL_VAR\s0 NAME=widget_body \-\->
    </div>
</div>
.PP
widget_body.html:
<div>
    <div>I am the widget body!</div>    
    <div><!\-\- \s-1TMPL_VAR\s0 NAME=some_widget_property \-\-></div>
</div>
.PP
my \f(CW$widget\fR = {
    \s-1NAME\s0 => 'widget',
    widget_body => {
        \s-1NAME\s0 => 'widget_body',
        some_widget_property => 'Totally useless widget'
    }
};
.PP
print \f(CW$nest\fR\->to_html( \f(CW$widget\fR );
.PP
#output:
<div class='widget'>
    <h4>I am a widget</h4>
    <div>
        <div>
            <div>I am the widget body!</div>    
            <div>Totally useless widget</div>
        </div>
    </div>
</div>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Template
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Gracey tomgracey@gmail.com
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2016 by Tom Gracey
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.20.1 or,
at your option, any later version of Perl 5 you may have available.
